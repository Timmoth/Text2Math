{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Text2Math Contains a well tested simple mathematical expression evaluator. Language expression : term ((plus | minus ) term)* term : factor((mul | div | caret | mod) factor)* factor : number | log | sin | cos | tan | sqrt | plus | minus | pi | e | lparen expression rparen Language expression : term ((plus | minus ) term)* term : factor((mul | div | caret | mod) factor)* factor : number | variable | log | sin | cos | tan | sqrt | plus | minus | pi | e | lparen expression rparen Name Description Examples number double precision floating point number \"1.23\", \".23\", \"4\", \"-1\", \"+2\" parentheses Grouping expressions to enforce precedence in calculations \"(1+2) / 3\" multiplication Multiplication of two numbers \"1 * 2\" division Division of one number by another \"1 / 2\" addition Addition of two numbers \"1 + 2\" subtraction Subtraction of one number from another \"1 - 2\" exponent Raising a number to the power of another number \"2 ^ 2\" natural logarithm Natural logarithm (base e) of a number \"log 2\", \"log(pi/2) square root Square root of a number \"sqrt 2\", \"sqrt(pi/2) sine Sine of an angle (in radians) \"sin 2\", \"sin(pi/2) cosine Cosine of an angle (in radians) \"cos 2\", \"cos(pi/2) tangent Tangent of an angle (in radians) \"tan 2\", \"tan(pi/2) pi The mathematical constant \u03c0 (approximately 3.14159) \"pi\" euler The mathematical constant e (approximately 2.71828) \"e\" variable A named value passed in externally during evaluation \"x\", \"testvar\" Usage var result = \"sqrt(x^2 + (sin(x) / cos(x))^2) + log(e^y)\" . Evaluate (( \"x\" , 2 ), ( \"y\" , 3 )) Benchmarks Benchmark Expression sqrt(.4 ^ 2) - (4 * tan 5 - cos(-2)) / sin(e^4) + log(pi - 1.2) Benchmark Results Method Mean Error StdDev Gen0 Allocated Tokenization 282.2 ns 5.32 ns 5.47 ns 0.0048 40 B Tokenization + Parsing 710.9 ns 13.44 ns 14.38 ns 0.0782 656 B Tokenization + Parsing + Evaluation 817.0 ns 14.31 ns 14.69 ns 0.0782 656 B Notes I've made the library as extensible as possible, it shouldn't be too difficult to add aditional functions - PR's are welcome! I've tried to make the library as efficient as possible by using readonly spans to keep memory allocation down","title":"Overview \u2705"},{"location":"#text2math","text":"Contains a well tested simple mathematical expression evaluator.","title":"Text2Math"},{"location":"#language","text":"expression : term ((plus | minus ) term)* term : factor((mul | div | caret | mod) factor)* factor : number | log | sin | cos | tan | sqrt | plus | minus | pi | e | lparen expression rparen","title":"Language"},{"location":"#language_1","text":"expression : term ((plus | minus ) term)* term : factor((mul | div | caret | mod) factor)* factor : number | variable | log | sin | cos | tan | sqrt | plus | minus | pi | e | lparen expression rparen Name Description Examples number double precision floating point number \"1.23\", \".23\", \"4\", \"-1\", \"+2\" parentheses Grouping expressions to enforce precedence in calculations \"(1+2) / 3\" multiplication Multiplication of two numbers \"1 * 2\" division Division of one number by another \"1 / 2\" addition Addition of two numbers \"1 + 2\" subtraction Subtraction of one number from another \"1 - 2\" exponent Raising a number to the power of another number \"2 ^ 2\" natural logarithm Natural logarithm (base e) of a number \"log 2\", \"log(pi/2) square root Square root of a number \"sqrt 2\", \"sqrt(pi/2) sine Sine of an angle (in radians) \"sin 2\", \"sin(pi/2) cosine Cosine of an angle (in radians) \"cos 2\", \"cos(pi/2) tangent Tangent of an angle (in radians) \"tan 2\", \"tan(pi/2) pi The mathematical constant \u03c0 (approximately 3.14159) \"pi\" euler The mathematical constant e (approximately 2.71828) \"e\" variable A named value passed in externally during evaluation \"x\", \"testvar\"","title":"Language"},{"location":"#usage","text":"var result = \"sqrt(x^2 + (sin(x) / cos(x))^2) + log(e^y)\" . Evaluate (( \"x\" , 2 ), ( \"y\" , 3 ))","title":"Usage"},{"location":"#benchmarks","text":"Benchmark Expression sqrt(.4 ^ 2) - (4 * tan 5 - cos(-2)) / sin(e^4) + log(pi - 1.2) Benchmark Results Method Mean Error StdDev Gen0 Allocated Tokenization 282.2 ns 5.32 ns 5.47 ns 0.0048 40 B Tokenization + Parsing 710.9 ns 13.44 ns 14.38 ns 0.0782 656 B Tokenization + Parsing + Evaluation 817.0 ns 14.31 ns 14.69 ns 0.0782 656 B","title":"Benchmarks"},{"location":"#notes","text":"I've made the library as extensible as possible, it shouldn't be too difficult to add aditional functions - PR's are welcome! I've tried to make the library as efficient as possible by using readonly spans to keep memory allocation down","title":"Notes"},{"location":"contributing/","text":"Contributing \ud83d\ude4f Contributions are welcome! Here\u2019s how you can get involved: Fork the repository : Click the \"Fork\" button at the top right of this page. Clone your fork : git clone https://github.com/Timmoth/Text2Math.git Create a branch : Make your changes in a new branch. git checkout -b my-feature-branch Commit your changes : git commit -m 'Add some feature' Push to the branch : git push origin my-feature-branch Open a pull request : Describe your changes and submit your PR.","title":"Contributing \ud83d\ude4f"},{"location":"contributing/#contributing","text":"Contributions are welcome! Here\u2019s how you can get involved: Fork the repository : Click the \"Fork\" button at the top right of this page. Clone your fork : git clone https://github.com/Timmoth/Text2Math.git Create a branch : Make your changes in a new branch. git checkout -b my-feature-branch Commit your changes : git commit -m 'Add some feature' Push to the branch : git push origin my-feature-branch Open a pull request : Describe your changes and submit your PR.","title":"Contributing \ud83d\ude4f"},{"location":"internals/","text":"Lexer Tokens are the fundamental building blocks of a programming language, each serving a distinct purpose and conforming to a specific pattern that can be used to identify it from the input source code. A sequence of characters in the source code that matches a token's pattern is known as a lexeme . The role of a lexer (or tokenizer) is to process the source code and translate it into a sequence of tokens. The tokens used in this project are as follows and are defined in the TokenType enum. name example number 1.2 plus + minus - mul * div / mod % lparen ( rparen ) caret ^ log log pi pi euler e sqrt sqrt sin sin cos cos tan tan variable testvar The lexer class distills the source code into a sequence of tokens. Each call to the NextToken method performs the following steps to update the CurrentToken : If the lexer has reached the end of the source code, it will return an end-of-file (Eof) token. The lexer will skip over / ignore any whitespace (' ') it encounters. If the lexer encounters a digit or a '.' character, it will buffer them and return a numeric token. If the lexer encounters a single symbol or a sequence of letters, it will match them to a known token pattern from the table above. For example given the source code: 1.2 + sqrt(2 * pi) The lexer will return the following sequence of tokens: number, plus, sqrt, lparen, number, mul, pi, rparen Parser Our parser's job is to take the sequence of tokens produced by the lexer and use them to build an Abstract Syntax Tree (AST) comprised of nodes, each representing a specific construct from the source code. Once constructed, the AST can be traversed to execute or further process the program. All AST node can be found here . AST for the expression 1 + 2: AdditionNode evaluate(left + right) \u251c\u2500\u2500 L \u2500 NumericNode evaluate(1) \u251c\u2500\u2500 R \u2500 NumericNode evaluate(2) AST for the expression pi + 2 * 3: AdditionNode evaluate(left + right) \u251c\u2500\u2500 L \u2500 PiNode evaluate(Math.Pi) \u251c\u2500\u2500 R \u2500 MultiplicationNode evaluate(left * right) \u251c\u2500\u2500 L \u2500 NumericNode evaluate(2) \u2514\u2500\u2500 R \u2500 NumericNode evaluate(4) Grammar The grammar rules define how expressions are structured in the language: term : factor ((mul | div | caret | mod) factor)* factor : number | variable | log | sin | cos | tan | sqrt | plus | minus | pi | e | lparen expression rparen expression : term ((plus | minus) term)* Term term : factor ((mul | div | caret | mod) factor)* A term consists of a factor followed by zero or more instances of a multiplication (*), division (/), exponentiation (^), or modulo (%) operator and another factor. Factor factor : number | log | sin | cos | tan | sqrt | plus | minus | pi | e | lparen expression rparen A number (e.g., 3, 4.5) A variable (e.g., x, testvar) A log function (e.g., log(10)) A sin function (e.g., sin(pi/2)) A cos function (e.g., cos(0)) A tan function (e.g., tan(pi/4)) A sqrt function (e.g., sqrt(4)) A unary plus (+) indicating a positive number (e.g., +3) A unary minus (-) indicating a negative number (e.g., -5) The mathematical constants pi or e An expression enclosed in parentheses (lparen expression rparen) Expression expression : term ((plus | minus) term)* An expression consists of a term followed by zero or more instances of a plus (+) or minus (-) operator and another term. Evaluation In our implementation , each node in the AST has an Evaluate method, which takes an array of variable values and when called, returns the result of its operation. For instance, an AdditionNode has two child nodes; when its Evaluate method is called, it will call the Evaluate method on each of the child nodes passing down the variable array and then return the sum of their results.","title":"Internals \u2705"},{"location":"internals/#lexer","text":"Tokens are the fundamental building blocks of a programming language, each serving a distinct purpose and conforming to a specific pattern that can be used to identify it from the input source code. A sequence of characters in the source code that matches a token's pattern is known as a lexeme . The role of a lexer (or tokenizer) is to process the source code and translate it into a sequence of tokens. The tokens used in this project are as follows and are defined in the TokenType enum. name example number 1.2 plus + minus - mul * div / mod % lparen ( rparen ) caret ^ log log pi pi euler e sqrt sqrt sin sin cos cos tan tan variable testvar The lexer class distills the source code into a sequence of tokens. Each call to the NextToken method performs the following steps to update the CurrentToken : If the lexer has reached the end of the source code, it will return an end-of-file (Eof) token. The lexer will skip over / ignore any whitespace (' ') it encounters. If the lexer encounters a digit or a '.' character, it will buffer them and return a numeric token. If the lexer encounters a single symbol or a sequence of letters, it will match them to a known token pattern from the table above. For example given the source code: 1.2 + sqrt(2 * pi) The lexer will return the following sequence of tokens: number, plus, sqrt, lparen, number, mul, pi, rparen","title":"Lexer"},{"location":"internals/#parser","text":"Our parser's job is to take the sequence of tokens produced by the lexer and use them to build an Abstract Syntax Tree (AST) comprised of nodes, each representing a specific construct from the source code. Once constructed, the AST can be traversed to execute or further process the program. All AST node can be found here . AST for the expression 1 + 2: AdditionNode evaluate(left + right) \u251c\u2500\u2500 L \u2500 NumericNode evaluate(1) \u251c\u2500\u2500 R \u2500 NumericNode evaluate(2) AST for the expression pi + 2 * 3: AdditionNode evaluate(left + right) \u251c\u2500\u2500 L \u2500 PiNode evaluate(Math.Pi) \u251c\u2500\u2500 R \u2500 MultiplicationNode evaluate(left * right) \u251c\u2500\u2500 L \u2500 NumericNode evaluate(2) \u2514\u2500\u2500 R \u2500 NumericNode evaluate(4)","title":"Parser"},{"location":"internals/#grammar","text":"The grammar rules define how expressions are structured in the language: term : factor ((mul | div | caret | mod) factor)* factor : number | variable | log | sin | cos | tan | sqrt | plus | minus | pi | e | lparen expression rparen expression : term ((plus | minus) term)*","title":"Grammar"},{"location":"internals/#term","text":"term : factor ((mul | div | caret | mod) factor)* A term consists of a factor followed by zero or more instances of a multiplication (*), division (/), exponentiation (^), or modulo (%) operator and another factor.","title":"Term"},{"location":"internals/#factor","text":"factor : number | log | sin | cos | tan | sqrt | plus | minus | pi | e | lparen expression rparen A number (e.g., 3, 4.5) A variable (e.g., x, testvar) A log function (e.g., log(10)) A sin function (e.g., sin(pi/2)) A cos function (e.g., cos(0)) A tan function (e.g., tan(pi/4)) A sqrt function (e.g., sqrt(4)) A unary plus (+) indicating a positive number (e.g., +3) A unary minus (-) indicating a negative number (e.g., -5) The mathematical constants pi or e An expression enclosed in parentheses (lparen expression rparen)","title":"Factor"},{"location":"internals/#expression","text":"expression : term ((plus | minus) term)* An expression consists of a term followed by zero or more instances of a plus (+) or minus (-) operator and another term.","title":"Expression"},{"location":"internals/#evaluation","text":"In our implementation , each node in the AST has an Evaluate method, which takes an array of variable values and when called, returns the result of its operation. For instance, an AdditionNode has two child nodes; when its Evaluate method is called, it will call the Evaluate method on each of the child nodes passing down the variable array and then return the sum of their results.","title":"Evaluation"},{"location":"releases/","text":"Version Description 8.0.0 Initial","title":"Releases \ud83d\udcd2"},{"location":"support/","text":"Need help? Ping me on linkedin and I'd be more then happy to jump on a call to debug, help configure or answer any questions.","title":"Support \ud83d\udedf"}]}